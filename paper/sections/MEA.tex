% !TEX root = ../MemPod.tex

\section{Predicting Hot Regions}
\label{sec:MEA}

%Memory management mechanisms need the ability to monitor and profile accesses to memory in order to identify hot regions and migrate them. Traditionally, a full set of counters is used, with one counter per physical page -- or region depending on the mechanism's granularity -- in order to accurately keep count of all accesses to all regions. Periodically these counters must be sorted in order to identify the regions with the highest counts. The identified regions will serve as a ``prediction'' for the next interval (i.e. the hottest page of the current interval will be amongst the hottest pages of the following intervals).

Migration mechanisms need the ability to predict \textit{future} hot pages to migrate them into fast memory. Prediction accuracy can have a high impact on performance benefits since after a bad prediction, the penalty paid for migrating a page -- or region depending on the mechanism's granularity -- will never be salvaged. A commonly used practice is to identify the hot regions within an interval and assume that those regions will be hot in the next interval. To accurately identify the hottest regions some mechanisms use one counter per region. In this case, at the end of each interval the counters need to be sorted before identifying the highest ranked regions. However, application phase changes could render this costly approach unsuccessful. Additionally, the number of necessary counters increases linearly as memory capacities grow.

Alternative approaches and heuristics exist in the literature for identifying the most frequently occurring elements in a set. The ``Majority Element Algorithm'' $(MEA)$ was originally proposed in \cite{karp-mea} and studied in-depth in \cite{charikar-mea} for database management and big data analytics. This heuristic is formally proven to correctly identify the $K$ most frequently occuring elements of a set, when each of those elements appears more than $N \over K+1$ (i.e. has majority), where $N$ is the number of elements in that set. 

%MemPod uses the ``Majority Element Algorithm'' $(MEA)$ for its activity tracking needs. MEA attempts to identify the \textit{majority} elements in a set. For example in an array with integers, MEA can be used to identify the \textit{K majority numbers}. Majority elements are the most frequently occurring elements, as long as they exist more than $N \over K+1$ times in the information stream (i.e. they have majority), where N is the number of elements in the array.

%The MEA algorithm was originally proposed in \cite{karp-mea} and studied in-depth in \cite{charikar-mea} as a heuristic capable of efficiently identifying majority elements in a stream. This algorithm is formally proven to be 100\% accurate, as long as the K most frequently occurring elements it must identify have majority. With complexity $O(N)$ it could be an ideal candidate for real-time streams of information, such as a stream of memory requests.


\setlength{\textfloatsep}{5pt}
\begin{algorithm}[t]
\centering
% \small
% \DontPrintSemicolon
% %\dontprintsemicolon
% \;
% \PrintSemicolon
% %\printsemicolon
% 
% \KwIn{X: Set of N elements}
% \KwIn{K: Number of elements to output}
% \KwData{T: Map structure with K entries}
% \KwResult{Set of K majority elements}
% \DontPrintSemicolon
% %\dontprintsemicolon
% \;
% Initialization: $T \leftarrow \emptyset$\; 
% \;
% \PrintSemicolon
% %\printsemicolon
% \ForEach{$i \in X$} {
% 	\uIf{$i \in T$}{
%		$T[i] \leftarrow T[i] + 1$\;
%	}
%	\uElseIf{$|T| < K - 1$}{
%		$T[i] = 1$\;
%	}
%	\Else{
%		\ForAll{$j \in T$}{
%			$T[j] \leftarrow T[j] - 1$\;
%			\lIf{$T[j] == 0$}{$T \leftarrow T \setminus {j}$}
%		}
%	} 
% }
% 
 \includegraphics[scale=0.8]{figures/mea_algorithm.pdf}
 %\caption{Majority Element Algorithm}
 \label{alg:mea}
\end{algorithm}

%\begin{algorithm}
%	\includegraphics[width=0.45\textwidth]{figures/mea_algorithm.pdf}
%	\caption{TEST}
%	\label{alg:mea}
%\end{algorithm}

The MEA algorithm is presented in Algorithm \ref{alg:mea}: A map structure of K entries holds the element's ID (in our integer array example that would be the integer's value) and maps it to a counter. Looping through the array, if the next integer exists in the map it increases its counter by 1. Otherwise, if there's enough room in the map it adds the new entry with a count of 1. If the number does not exist in the map and all K counters are occupied, the algorithm subtracts 1 from every counter, removes the entries with a counter value of 0 and proceeds to the next integer. Once the entire array is processed, the map entries hold the majority elements. 

%Even though this heuristic is 100\% accurate, in the absence of its main assumption no guarantees can be made. The outcome of this algorithm relies on several uncontrolled variables, such as the order our requests appeared in. However, the nature of the algorithm presents a very welcomed side effect: Elements accessed repeatedly can be evicted from the map by elements that were accessed less times but more recently. This observation reveals MEA's favoritism towards temporal locality. Furthermore, the area overhead of this algorithm implemented in hardware remains constant, regardless of how many elements need to be profiled (i.e. regardless of how many pages exist in main memory). 

It would be unreasonable to expect that in a stream of memory requests MEA's assumption will be satisfied. It's also important to note that in the absence of this assumption no guarantees can be made on the outcome. However, MEA presents many traits that should make us consider it as a candidate: First, elements accessed repeatedly can be evicted from the map by elements that were accessed less times but more recently. This observation reveals MEA's favoritism towards temporal locality even in the absence of the assumption. Second, MEA's area overhead remains constant regardless of the size of the input set (in our case the number of regions in memory). Third, its $O(N)$ complexity can work well with a stream of requests. Finally, the need for sorting counters is now eliminated.

%In a memory management scheme that uses Full Counters and a scenario where we want to identify the 100 ``hottest'' pages, we would need one full counter per memory page and on top of that we would have to periodically sort all those counters to pick the top 100. With the use of MEA counters we only need a map with 100 entries regardless of the actual number of pages in main memory. In an 8GB memory with 2kB pages and looking for the top 100 pages, MEA needs $\sim$5K times fewer bits than the full counters' storage requirements (4MB Vs 850B). Considering all the potential benefits MEA can offer in theory, we compared its counting and prediction accuracy against the Full Counters (FC) scheme. 

\subsubsection*{MEA Evaluation}

With these traits in mind, we evaluated MEA's counting and prediction accuracy and compared it against the Full Counters (FC) scheme. We used memory traces captured from multi-programmed 8-core workloads (the same traces used and described in Section \ref{sec:Results}) and simulated MEA and FC side-by-side with an in-house off-line simulator that provides oracle knowledge of future intervals. The interval size for both MEA and FC was set at 5500 requests which is the average number of requests serviced within a 50us window in our timing experiments. We compared the two mechanisms based on their counting and prediction accuracies regarding the top 3 tiers of memory pages. Pages ranked in the 1-10 hottest pages were grouped in tier 1, tier 2 holds pages ranked 11-20 and finally tier 3 holds pages 21-30. 

First we compared MEA's counting accuracy against FC's guaranteed correct counting. In other words we evaluate MEA's capability of identifying the hottest pages of the current interval accurately. Figure \ref{fig:mea_1} shows the counting accuracy of MEA in the top 3 tiers. In some workloads, MEA scored up to 75\% accuracy in the top three tiers. However, on average MEA reports accuracy below 40\% on the top tiere. Our results show that in our use cases MEA is not a viable option in terms of accurate counting. However, correct counting accuracy does not necessarily translate to accurate predictions during future interval(s), even though intuitively, these two aspects might seem correlated.

\begin{figure}[t]
\centering
%  \includegraphics[width=0.46\textwidth, height=9em]{figures/mea_1_v2.pdf}
  \includegraphics[scale=.3]{figures/mea_1_v2.pdf}
  \caption{MEA counting accuracy compared to Full Counters on the top three tiers (ranks 1-10, 11-20, 21-30). Average results for homogeneous(AVG HG), mixed (AVG MIX) and all (AVG ALL) workloads shown due to space limitations.}
  \label{fig:mea_1}
\end{figure}

Figures \ref{fig:mea_2} presents a comparison of MEA and FC in terms of prediction accuracy and demonstrates MEA's true potential. Following the same structure as Figure \ref{fig:mea_1}, we compare each mechanism's ``predictions'' against the top three tiered pages of the following interval (oracle knowledge). Based on our oracle knowledge of the following interval, Figure \ref{fig:mea_2} plots the number of hits on predicted hot pages of the previous interval. We also selected the most interesting individual benchmarks and show them in Figure \ref{fig:mea_3} to provide a more detailed comparison. 

On average, MEA achieves more future hits than FC by 16\%, 81\% and 68\% on the top three tiers respectively. Figure \ref{mea_3} shows some selected individual workloads that generated the most interesting results and provide a more complete comparison. Cactus\footnote{We use a single benchmark's name as a shorthand for a workloads running the same benchmark 8 times simultaneously on 8 cores.} is the \textit{only workload} where FC outperformed HMA's prediction. In fact it outperformed HMA on every tier. Mix9 and xalanc are ``normal'' workloads, one homogeneous and one mixed. The majority of our workloads reported similar trends as these two. We can see MEA outperforming FC's prediction accuracy in every tier. The last two workloads we selected, bwaves and lbm, show FC failing entirely to predict the future (FC also scored zero future hits with our libquantum workload). With bwaves (and libquantum) MEA reports a very low number of future hits but not zero. Lbm shows the most interesting result of our comparison, where MEA reports one of its highest results in a workloads where FC failed entirely.

\begin{figure}[t]
\centering
  \includegraphics[scale=.3]{figures/mea_2_v2.pdf}
  \caption{MEA prediction accuracy (part 1) compared to Full Counters on the top three tiers (ranks 1-10, 11-20, 21-30). Results for homogeneous(WL-HG), mixed (WL-MIX) and all (WL-ALL) workloads shown due to space limitations.}
  \label{fig:mea_2}
\end{figure}

\begin{figure}[t]
\centering
  \includegraphics[scale=.45]{figures/mea_3_v2.pdf}
  \caption{MEA prediction accuracy (part 2). This graph presents the most interesting results from individual workloads.}
  \label{fig:mea_3}
\end{figure}

Proposed in 2003, to the best of our knowledge, MEA has not been used in any micro-architectural proposal before. Our results indicate it can well the very expensive option of full counters at greatly reduced hardware cost.
